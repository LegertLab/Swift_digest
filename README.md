# iOS Development_digest (Swift)


## Введение

Привет! Я Настя, изучаю iOS разработку с нуля (имеются базовые знания в области фронтенда). 
Это справочник по iOS разработке, в котором я систематизирую все знания, которые получаю из различных источников (различные англо- и русскоязычные курсы, статьи, Youtube и тд). 

### Проблематика
К сожалению, изучив подход наиболее популярных курсов, я не нашла оптимального для себя - когда у студента создается целостная картина того, как надо разрабатывать приложение. В основном даются частные задачи и их решение без обоснования, почему именно так надо делать, какие еще есть варианты и решения и на основании чего принимать это решение. Получается набор обрывочных знаний, без понимания, где ты сейчас находишься на пути своего развития как iOS разработчка, и сколько еще нужно пройти до достижения следующей промежуточной цели. Собственно, и цели практически мало где обозначены. 

### Решение
В связи с указанной проблематикой я решила создать некую "шпаргалку" или справочник по iOS разработке, в котором будет ясно описан процесс разработки с указанием всех важных компонентов и составляющих. Таким образом, у читателя должно сложиться понимание масштаба процесса, четкое видение карты своего развития, зон роста, а также появится быстрый доступ к знаниям  - как решать те или иные задачи на Swift. 

### Версия документа
Документ разрабатывается в режиме реального времени, разделы обновляются и дополняются постоянно. 

### Источники
+ https://habr.com/ru/post/437300/
+ "Чистая архитектура" Роберт Мартин
+ https://github.com/goingreen/iOSMobileJuniorIntro
***

## Справочник по iOS разработке

### Цели, задачи, функции приложения
Как ведется работа по развитию идеи приложения, работа с целевой аудиторией, маркетинговые исследования, анализ конкурентов и тп. 
### Создание макета приложения
При первичном проектировании приложения описываются действия пользователя (например, в виде блок-схем), переходы, необходимые экраны, функции, элементы интерфейса, контент и тп.

Для разработки дизайна используется документ Human Interface Guide, в котором даны ключевые рекомендации по проектированию внешнего вида и поведения элементов приложения (и другое).

### Архитектура приложения

На основании макета приложения и его бизнес-логики разрабатывается оптимальная архитектура приложения, в которой описываются применяемые паттерны проектирования, взаимодейсвие модулей и блоков, стек технологий, библиотек и тп.

#### Парадигмы программирования
+ Структурное программирование
+ Объектно-ориентированное программирование
+ Функциональное программирование

#### Архитектурные паттерны
+ MVC (разобрать подробнее)
+ MVVM (разобрать подробнее)
+ MVP
+ VIPER 

#### Жизненный цикл ViewController

При открытии, перевороте экрана, открытии и закрытии модальных View и собственно закрытии ViewController'а у него срабатывают встроенные методы, а также происходит инициализация свойств и outlet'ов. 
Последовательность вызова методов и инициализации свойств:
Открываем новый ViewController:
**awakeFromNib** 
Не является частью жизненного цикла ViewController'а, но он вызывается сразу после инициализации перед подготовкой перехода у контроллера, который задан через Storyboard.
**loadView**
Используется при ручной инициализации View, можно задать кастомные начальные параметры (цвет фона и тп). По умолчанию вызывается автоматически.
**someProperties** (инициализация свойств класса)
**closeButton** (инициализация @IBOutlet)
Теперь к свойствам можно обращаться.
**viewDidLoad** (View загрузился)
Внутри метода viewDidVoad можно инициализировать переменные и объекты, которые понадобятся на протяжении жизненного цикла View. Но границы View еще не установлены, и мы не можем обращаться к значениям высоты, ширины и прочим параметрам. Обращаемся к суперклассу.
**viewWillAppear** (View сейчас появится)
Этот метод сообщает нам, что View следующим шагом появится на экране, будет добавлен в текущую иерархию, перед обработкой какой-либо анимации. Этот метод можно использовать для более тонкой настройки subViews, которую нужно сделать до анимации. Например, поменять стиль статус-бара или стиль всего View. Обращаемся к суперклассу.
**updateViewConstraints** 
Вызываем этот метод перед viewWillLayoutSubViews, если необходимо изменить значения констант констрейнтов кодом. В конце метода обращаемся к суперклассу.
**viewWillLayoutSubViews** (View собирается подстроиться под размер экрана)
Теперь устанавливаются границы View и геометрические значения становятся доступны. Между методами viewWillLayoutSubViews и viewDidLayoutSubviews срабатывает AutoLayout. То есть эти методы вызываются до начала и расстановки и после расстановки - для контроля правильного выполнения расстановки.
Если не используем AutoLayout, то именно в этом методе устанавливаем размеры SubViews и их положение.
**viewDidLayoutSubviews** (View подстроился под размер экрана)
В этом методе можно устанавливать последние состояния объектов (выделенную ячейку, состояние скролла и тп).
**viewDidAppear** (View появился на экране)
Метод вызывается, когда представление уже загружено, и мы хотим что-то показать. Данный метод завершает цепочку появления View, и он может быть вызван несколько раз - например, после закрытия модального окна (когда наш View снова оказался видимым. В этом случае также срабатывает и viewWillAppear. Здесь не стоит хранить свойства и экземпляры объектов, так как это вызовет утечку памяти, если не отпустить методы, когда View изчезнет. Здесь можно размещать ресурсоемкие операции, оповестив об этом пользователя. Обращаемся к суперклассу.

Закрываем ViewController:
**viewWillDisappear** (View будет закрыт(скрыт из виду))
Здесь обычно коммитят изменения- убирают firstResponderStatus, ставят на паузу выполняемые действия, отменяют ориентацию, стиль статус-бара, если их меняли в методе viewWillAppear. Можно почистить данные, обнулить кэш, поставить на паузу плеер. Сброс значений параметров и отключение анимации. Обращаемся к суперклассу.
**viewDidDisappear** (View закрыт(скрыт))
Метод сообщает о том, что view было удалено из иерархии. В целом, его применение схоже с применением viewWillDisappear, но он выполняется после анимации удаления View (а предыдущий - перед).
При этом сам View не выгружается из памяти. Метод срабатывает после выполнения метода viewDidAppear другого View (модального, например). Инымы словами, когда мы открываем модальное окно, оно каждый раз DidLoad, и после закрытия каждый раз освобождает память. Наш же основной View так и остается загруженным, меняется только его статус видимости. Обращаемся к суперклассу.

**viewWillTransition(to size: CGSize, ...)** (кастомная обработка анимации при повороте экрана)

**deinit** (View выгружен из памяти)

**didReceiveMemoryWarning** (сработало переполнение памяти, приложение закрывается)
В этом методе можно предупредить пользователя, что приложение будет закрыто, попробовать обнулить неиспользуемые объекты, а также сохранить данные при необходимости. Обращаемся к суперклассу.


### Разработка интерфейса
#### Способы создания интерфейса
+ визуальный способ через Interface Builder
+ полностью описать интерфейс из кода
+ комбинированный вариант, когда часть содержимого экранов заведена через Interface Builder, а их настройка вынесена в код.

#### Основные компоненты интерфейса
+ набор компонентов (изучить особенности каждого компонента)
+ работа с библиотекой UIKit
+ создание адаптивных экранов  - Auto Layout
+ способы представление данных: UITableView, UICollectionView

### Хранение данных
+ Keychain (для чего-то небольшого и секретного)
+ UserDefaults (для небольших настроек)
+ Core Data (для хранения объектов, связей между ними)
+ SQLite, Realm, Firebase (разобраться позже)

### Работа с сетью, получение данных из JSON
#### Создание сетевого запроса
+ Базовый подход - URLSession
+ Alamofire (разобраться с этой библиотекой позже)

#### Получение и обработка данных
+ Обработка JSON-формата (получение и обработка данных, например, вывод списка)
- С применением стандартных средств языка
- С помощью библиотеки SwiftyJSON
- Codable

### Реализация многопоточности
#### Grand Central Dispatch

### Функционал swift

#### Протоколы и делегаты 
Нужно уметь создать протокол, назначить делегат, реализовать у него поддержку протокола. В каких ситуациях это можно понадобиться?

#### Сильные и слабые ссылки, ARC, утечки памяти
Как сделать так, чтобы у приложения не было проблем с нехваткой памяти?
Что такое ссылки, какие бывают типы ссылок? Что именно делает ARC, и как избежать Retain Cycle, и что это вообще такое?

### Решение частных стандартных задач из практики (шпаргалка)
#### Передача данных при переходе на новый экран

код в родительском View, откуда осуществляется переход:
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if segue.identifier == "GoToSecondVC" {
            let dvc = segue.destination as! SecondViewController
            dvc.someProperties = ""
        }
    }

код внутри класса SecondViewController, класс принимает в свое свойство someProperties пустую строку:
    var someProperties: String? {
        didSet {
            print("someProperties")
        }
    }

### Глоссарий
Прологирован - например, метод. В него включен метод print, который показывает в консоли необходимую нам информацию для контроля выполнения кода
